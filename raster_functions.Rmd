---
title: "Functionalizing NEON Rasters"
author: "Enrique Monta&ntilde;o"
date: "June 21, 2016"
output: html_document
---

## Objectives

Objectives/tasks to work though:

1. Import a raster — A lidar canopy height model (lidar/Teak_lidarCHM.tif)
1. For the CHM, set values == 0 to NA (not trees)
1. Classify the raster according to some distribution – low medium and tall trees. This could be done using a histogram potentially or we could just decide that <2m is generally grasses / understory, <6m small trees,and the rest are tall trees. A function could import the desired thresholds. Visualize density and plot vertical cutoff lines.
1. Plot the classified raster, add a legend for each “class” - legends are super tricky to simplifying this process with a function would be good.  see: http://neon-workwithdata.github.io/neon-data-institute-2016/R/classify-by-threshold-R/  for my take on forcing a legend outside of the plot area using par settings. You may have other better forms of magic to make this work well. :)
1. Export the plot figure to a pdf – publishable
1. Export the classified raster as a geotiff with NaFlagg = -9999 to an outputs folder.

## Load Libraries
```{r load-libraries}
library(raster)
library(rgdal)
library(rhdf5)

```

## Import CHM Raster

```{r import-chm}
# setting some parameters
# raster filename
chm_file <- "../NEONdata/D17-California/TEAK/2013/lidar/TEAK_lidarCHM.tif"
# import the raster
chm <- raster(chm_file)

chosen_breaks <- c(0,6,30,100)

# set no data values; trees are > 0
chm[chm == 0] <- NA

# plot the density

density(chm,
     main = "Density of Teakettle Site CHM",
     xlab = "Height (m)")



#############################
# function to create a reclassify matrix from a set of breaks
create_height_class_matrix <- function(breaks) {
  # Get the length of the breaks vector to
  # figure how many classes
  br_len <- length(breaks)
  
  # Initialize height class vector with 0
  height_class_m <- c(0)
  
  # for input of breaks = c(6, 30, 50, 100) we expect:
  # c(0, 6, 1,
  #   6, 30, 2,
  #   30, 50, 3,
  #   50, 100, 4)
  
  for (i in 1:br_len) {
    height_class_m <- c(height_class_m, breaks[i - 1], breaks[i], i)
  }
  
  reclass_height_mat <- matrix(height_class_m,
                               ncol = 3,
                               byrow = TRUE)
  
  return(reclass_height_mat)
}

create_height_class_matrix(chosen_breaks)


# a function to plot density of heights with chosen breaks
# expects chm raster, a title, and a vector of breaks
plot_chm_density <- function(rast_in, site.name, bins) {
  density(rast_in,
          main = paste("Canopy Height Density\n", site.name),
          xlab = "Canopy Heights (m)")
  abline(v = bins, col = "red")
}

plot_chm_density(chm, site.name="Teakettle", bins = chosen_breaks)


# function to export to pdf
make_pdf <- function(expr, filename, ..., verbose = TRUE) {
  if (verbose) {
    message("Creating: ", filename)
  }
  pdf(file = filename, ...)
  on.exit(dev.off())
  eval.parent(substitute(expr))
}

make_pdf(plot_chm_density(rast_in = chm,
                          site.name = "Teakettle",
                          bins = chosen_breaks),
         filename = paste("TEAK_chm_density.pdf"),
         height=6, width=7)

# Perform the reclass
chm_rcl <- reclassify(chm,
                      rcl_m)


##########################################
##########################################
# function to plot the reclassified raster

plot_reclassified_raster <- function(rast.in, site.name, breaks){
        # this is a tricky bit because we need to out the legend
        # outside of the plot region
        
        # Get colors for plotting
        bin.colors <- rev(terrain.colors(length(breaks)))
        
        # make room for a legend
        
        par(xpd = FALSE, mar = c(5.1, 4.1, 4.1, 4.5))
        
        # plot
        plot(rast.in,
                 col = bin.colors,
                 main = paste("Canopy height classes \n", site.name),
                 legend = FALSE)
        
        # allow legend to plot outside of bounds
        par(xpd = TRUE)
        
        # legend x
        leg.x <- par()$usr[2] + 20
        
        # legend y
        leg.y <- par()$usr[4] + 50 - (abs(par()$usr[3] - par()$usr[4]) / 2) 
        
        # create legend text
        height.mat <- create_height_class_matrix(breaks)
        
        # initialize legend text
        legend.text <- c()
        
        for (i in 1:length(breaks)) {
                
                legend.text <- c(legend.text, 
                                                 paste0(height.mat[i, 1], "-", 
                                                            height.mat[i, 2], " m"))
        }
        
        # create the legend
        legend(leg.x, leg.y,  # set x,y legend location
                   legend = legend.text,  # make sure the order matches colors
                   fill = bin.colors,
                   bty = "n") # turn off border
        
        # turn off plotting outside of bounds
        par(xpd = FALSE)
}

plot_reclassified_raster(rast.in = chm, site.name = "Teakettle", breaks = chosen_breaks)

make_pdf(plot_reclassified_raster(rast.in = chm, site.name = "Teakettle", breaks = chosen_breaks),
         filename = "TEAK_reclassified_chm.pdf",
         height=7, width=6)

```

## Export the result

```{r export-chm}
# export geotiff
writeRaster(chm_rcl,
            filename="reclassify_Teak_chm.tif",
            format="GTiff",
            options="COMPRESS=LZW",
            overwrite = TRUE,
            NAflag = -9999)

```

## Document the environment

```{r doc-logfile}
sink(paste0(format(Sys.time(), "%y-%m-%d:%H%M%S"),
     "_sessionInfo.txt"))
sessionInfo()
sink()
```




